Je vais analyser en dÃ©tail votre situation pour comprendre pourquoi la publication Ã©choue systÃ©matiquement.

Je vais analyser en dÃ©tail votre situation pour comprendre pourquoi la publication Ã©choue systÃ©matiquement.

Show all
3 tools used
Maintenant laissez-moi regarder la fonction de publication et le contexte de l'erreur "Not Found":

Maintenant laissez-moi regarder la fonction de publication et le contexte de l'erreur "Not Found":

Show all
4 tools used
Parfait, j'ai maintenant une vision complÃ¨te de votre problÃ¨me. Laissez-moi vous expliquer ce qui bloque et vous donner un plan dÃ©taillÃ©.

ğŸ” DIAGNOSTIC DE L'ERREUR "NOT FOUND"
D'aprÃ¨s les requÃªtes rÃ©seau que j'ai analysÃ©es, votre backend retourne systÃ©matiquement :


{
  "ok": false,
  "status": "prepare_failed", 
  "reason": "Not Found"
}
Cette erreur se produit pendant la phase "prepare" de la publication, AVANT mÃªme d'essayer de publier sur Vinted. Le backend ne trouve pas quelque chose d'essentiel pour prÃ©parer la publication.

ğŸ¯ LES 4 CAUSES PROBABLES
Les photos ne sont pas trouvÃ©es sur le disque du serveur

Vos drafts contiennent des chemins comme /temp_photos/xxx.jpg
Le backend cherche probablement dans backend/data/temp_photos/xxx.jpg
Ou les photos ont Ã©tÃ© supprimÃ©es aprÃ¨s un certain temps
La session Vinted est expirÃ©e/absente

Le backend ne peut pas prÃ©parer la publication sans une session active
Votre cookie Vinted n'a peut-Ãªtre pas Ã©tÃ© sauvegardÃ© ou a expirÃ©
Le brouillon lui-mÃªme est incomplet

Certains champs obligatoires pour Vinted sont vides
Par exemple : condition, category, certaines infos manquantes
ProblÃ¨me de catÃ©gorie Vinted

Le backend essaie de mapper votre category vers un vinted_category_id
Cette catÃ©gorie n'existe pas dans la base Vinted
ğŸ“‹ PLAN D'ACTION COMPLET POUR PUBLIER SUR VINTED
PHASE 1 : DIAGNOSTIC BACKEND (30 min)
Ã‰tape 1.1 : Ajouter des logs dÃ©taillÃ©s dans /bulk/drafts/{draft_id}/publish
Dans ton endpoint de publication backend, ajoute ces logs AVANT toute tentative de publication :


@app.post("/bulk/drafts/{draft_id}/publish")
async def publish_bulk_draft(draft_id: str, options: dict = None):
    print(f"\n=== DÃ‰BUT PUBLICATION DRAFT {draft_id} ===")
    
    # 1. Charger le draft
    draft = load_draft(draft_id)  # ta fonction pour charger le draft
    if not draft:
        print(f"âŒ ERREUR: Draft {draft_id} introuvable en DB")
        return {"ok": False, "status": "prepare_failed", "reason": "Draft not found"}
    
    print(f"âœ… Draft chargÃ©: {draft['title']}")
    print(f"   - Photos: {draft.get('photos', [])}")
    print(f"   - Category: {draft.get('category')}")
    print(f"   - Condition: {draft.get('condition')}")
    print(f"   - Brand: {draft.get('brand')}")
    print(f"   - Size: {draft.get('size')}")
    
    # 2. VÃ©rifier les photos sur disque
    for photo_path in draft.get('photos', []):
        # Essayer plusieurs chemins possibles
        possible_paths = [
            photo_path,
            f"backend/data/{photo_path}",
            f"backend/data/temp_photos/{os.path.basename(photo_path)}",
            f"/tmp/{os.path.basename(photo_path)}"
        ]
        
        found = False
        for p in possible_paths:
            if os.path.exists(p):
                print(f"âœ… Photo trouvÃ©e: {p}")
                found = True
                break
        
        if not found:
            print(f"âŒ ERREUR: Photo introuvable: {photo_path}")
            print(f"   Chemins testÃ©s: {possible_paths}")
            return {
                "ok": False, 
                "status": "prepare_failed", 
                "reason": f"Photo introuvable: {os.path.basename(photo_path)}"
            }
    
    # 3. VÃ©rifier la session Vinted
    vinted_session = get_active_vinted_session()  # ta fonction
    if not vinted_session:
        print("âŒ ERREUR: Aucune session Vinted active")
        return {
            "ok": False,
            "status": "prepare_failed", 
            "reason": "Session Vinted expirÃ©e ou absente. Va dans Settings pour coller ton cookie."
        }
    
    print(f"âœ… Session Vinted active: user_id={vinted_session.get('user_id')}")
    
    # 4. Mapper la catÃ©gorie
    vinted_category_id = map_category_to_vinted(draft.get('category'))
    if not vinted_category_id:
        print(f"âŒ ERREUR: CatÃ©gorie '{draft.get('category')}' non mappÃ©e")
        return {
            "ok": False,
            "status": "prepare_failed",
            "reason": f"CatÃ©gorie '{draft.get('category')}' non reconnue par Vinted"
        }
    
    print(f"âœ… CatÃ©gorie mappÃ©e: {draft.get('category')} -> {vinted_category_id}")
    
    # 5. PrÃ©parer le payload Vinted
    vinted_payload = {
        "title": draft['title'],
        "description": draft.get('description', ''),
        "price": draft['price'],
        "category_id": vinted_category_id,
        "brand_id": get_brand_id(draft.get('brand')),  # si tu as un mapping
        "size_id": get_size_id(draft.get('size')),
        "status_id": get_condition_id(draft.get('condition')),
        "color_ids": [get_color_id(draft.get('color'))],
        "photos": [resolve_photo_path(p) for p in draft['photos']]
    }
    
    print(f"âœ… Payload Vinted prÃ©parÃ©: {vinted_payload}")
    
    # 6. MAINTENANT on peut essayer de publier sur Vinted
    # ... ton code de publication Playwright/Selenium
Ã‰tape 1.2 : CrÃ©er une fonction resolve_photo_path

def resolve_photo_path(photo_path: str) -> str:
    """Trouve le chemin absolu d'une photo en testant plusieurs emplacements"""
    possible_paths = [
        photo_path,
        f"backend/data/{photo_path}",
        f"backend/data/temp_photos/{os.path.basename(photo_path)}",
        f"/tmp/{os.path.basename(photo_path)}"
    ]
    
    for p in possible_paths:
        if os.path.exists(p):
            return os.path.abspath(p)
    
    raise FileNotFoundError(f"Photo introuvable: {photo_path}")
Ã‰tape 1.3 : Tester avec curl

curl -X POST "https://ton-backend.replit.dev/bulk/drafts/112f47df-dacd-41ca-ab07-752ff3838af4/publish" \
  -H "Authorization: Bearer TON_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"dry_run": false}'
RÃ©sultat attendu : Les logs vont te dire EXACTEMENT ce qui manque (photo, session, catÃ©gorie, etc.)

PHASE 2 : CORRIGER LES PROBLÃˆMES IDENTIFIÃ‰S (1h)
ScÃ©nario A : Photos introuvables
Solution : Modifier le code d'analyse de photos pour sauvegarder les chemins absolus


# Dans ton endpoint /bulk/photos/analyze
for file in uploaded_files:
    # Sauvegarder dans backend/data/temp_photos/
    save_path = f"backend/data/temp_photos/{uuid.uuid4()}.jpg"
    with open(save_path, 'wb') as f:
        f.write(await file.read())
    
    # Stocker le chemin COMPLET dans le draft
    draft_photos.append(save_path)  # PAS juste le nom de fichier
ScÃ©nario B : Session Vinted expirÃ©e
Solution : Aller dans /settings et recoller ton cookie Vinted frais

Ouvre Vinted dans ton navigateur
F12 â†’ Onglet RÃ©seau â†’ RafraÃ®chir la page
Clique sur n'importe quelle requÃªte vers vinted.fr
Copie TOUT le header Cookie (pas juste une partie)
Copie aussi le User-Agent
Va sur /settings dans ton app
Colle les deux valeurs et clique "Sauvegarder"
VÃ©rifie que le backend confirme la session
ScÃ©nario C : Champs manquants (condition, etc.)
Solution : Modifier le SYSTEM_PROMPT OpenAI pour forcer ces champs


SYSTEM_PROMPT = """
Tu dois OBLIGATOIREMENT retourner ces champs:
- title (string, non vide)
- description (string, au moins 50 caractÃ¨res)
- price (number, > 0)
- condition (string, EXACTEMENT UN DE: "Neuf avec Ã©tiquette", "Neuf sans Ã©tiquette", "TrÃ¨s bon Ã©tat", "Bon Ã©tat", "Satisfaisant")
- category (string, exemples: "Pulls & Gilets", "Pantalons & Jeans", "Robes", etc.)
- size (string, exemples: "XS", "S", "M", "L", "XL", "XXL")
- brand (string, si identifiable)
- color (string, exemples: "Noir", "Blanc", "Bleu", etc.)

SI UN CHAMP N'EST PAS IDENTIFIABLE, mets une valeur par dÃ©faut cohÃ©rente:
- condition: "Bon Ã©tat" (par dÃ©faut)
- category: "VÃªtements" (si vraiment incertain)
- size: "M" (si invisible sur photo)
"""
ScÃ©nario D : CatÃ©gorie non mappÃ©e
Solution : CrÃ©er un mapping robuste


CATEGORY_MAPPING = {
    "Pulls & Gilets": 20,  # ID Vinted pour "Pulls"
    "Pantalons & Jeans": 91,
    "Robes": 16,
    "VÃªtements": 1,  # CatÃ©gorie gÃ©nÃ©rique par dÃ©faut
    # ... ajouter toutes les catÃ©gories
}

def map_category_to_vinted(category: str) -> int:
    # Essayer exact match
    if category in CATEGORY_MAPPING:
        return CATEGORY_MAPPING[category]
    
    # Essayer fuzzy match
    for key in CATEGORY_MAPPING:
        if category.lower() in key.lower() or key.lower() in category.lower():
            return CATEGORY_MAPPING[key]
    
    # Fallback: catÃ©gorie gÃ©nÃ©rique
    return 1  # "VÃªtements"
PHASE 3 : CORRIGER LE FRONTEND (30 min)
Fix 1 : Le champ condition vide dans les drafts
ProblÃ¨me : Le backend renvoie "condition": "Bon Ã©tat" (franÃ§ais) mais le Select attend "good" (anglais)

Solution dÃ©jÃ  appliquÃ©e dans BulkDraftEdit.tsx : mapping bidirectionnel


const CONDITION_MAP = {
  "new_with_tags": "Neuf avec Ã©tiquette",
  "new_without_tags": "Neuf sans Ã©tiquette", 
  "very_good": "TrÃ¨s bon Ã©tat",
  "good": "Bon Ã©tat",
  "satisfactory": "Satisfaisant"
};

// Quand on charge le draft:
const frenchCondition = draft.condition; // "Bon Ã©tat"
const englishValue = Object.keys(CONDITION_MAP).find(
  key => CONDITION_MAP[key] === frenchCondition
); // "good"
âœ… Cette partie est dÃ©jÃ  corrigÃ©e cÃ´tÃ© front

Fix 2 : Upload de photos dans un draft existant
Backend nÃ©cessaire : CrÃ©er l'endpoint POST /bulk/drafts/{draft_id}/photos


@app.post("/bulk/drafts/{draft_id}/photos")
async def add_photos_to_draft(draft_id: str, files: List[UploadFile]):
    draft = load_draft(draft_id)
    if not draft:
        raise HTTPException(404, "Draft not found")
    
    new_photos = []
    for file in files:
        save_path = f"backend/data/temp_photos/{uuid.uuid4()}.jpg"
        with open(save_path, 'wb') as f:
            f.write(await file.read())
        new_photos.append(save_path)
    
    # Ajouter aux photos existantes
    draft['photos'].extend(new_photos)
    save_draft(draft_id, draft)
    
    return {"ok": True, "photos": draft['photos']}
Fix 3 : Titres et tailles trop complexes
Backend : Modifier le SYSTEM_PROMPT OpenAI


SYSTEM_PROMPT = """
RÃˆGLES STRICTES pour title:
- Maximum 60 caractÃ¨res
- Format: [Marque] [Type] [Couleur] [Taille]
- Exemple: "Burberry Jogging noir XS"
- PAS de mesures (cm, Y)
- PAS d'Ã©quivalences (â‰ˆ)
- PAS d'Ã©tat dans le titre

RÃˆGLES STRICTES pour size:
- UNIQUEMENT: XS, S, M, L, XL, XXL
- SI taille enfant dÃ©tectÃ©e (ex: 16Y): convertir en taille adulte Ã©quivalente
  - 14-16Y -> XS
  - 16-18Y -> S
- Si incertain: "M" par dÃ©faut
- CRÃ‰ER UN NOUVEAU CHAMP size_details pour les dÃ©tails (ex: "16Y / 165 cm")
"""
PHASE 4 : TESTS & VALIDATION (30 min)
Test 1 : CrÃ©er un nouveau draft propre
Va sur /bulk-upload
Upload 1-2 photos d'un article simple (t-shirt uni par exemple)
Attends la gÃ©nÃ©ration du draft
Va dans le draft
VÃ©rifie que TOUS les champs sont remplis (surtout condition)
Clique "Sauvegarder"
Test 2 : Publier en dry-run
Dans le mÃªme draft, clique "Publier"
VÃ©rifie dans les logs backend que toutes les Ã©tapes passent :
âœ… Draft chargÃ©
âœ… Photo trouvÃ©e
âœ… Session Vinted active
âœ… CatÃ©gorie mappÃ©e
âœ… Payload prÃ©parÃ©
Si dry-run rÃ©ussit â†’ passe au test rÃ©el
Test 3 : Publication rÃ©elle
Assure-toi que ta session Vinted est fraÃ®che (< 24h)
Clique "Publier" en mode rÃ©el
Surveille les logs backend pour voir oÃ¹ Ã§a bloque
Si captcha Vinted â†’ normal, complÃ¨te-le manuellement
Test 4 : VÃ©rifier sur Vinted
Va sur ton profil Vinted
VÃ©rifie que l'article est bien publiÃ©
VÃ©rifie que les photos, titre, prix correspondent
PHASE 5 : OPTIMISATIONS (bonus)
AmÃ©lioration 1 : Retry automatique si session expirÃ©e

def publish_with_retry(draft_id: str, max_retries=2):
    for attempt in range(max_retries):
        try:
            return publish_to_vinted(draft_id)
        except VintedSessionExpired:
            if attempt < max_retries - 1:
                print("Session expirÃ©e, attente de nouveau cookie...")
                time.sleep(60)  # Attendre que l'utilisateur recolle son cookie
            else:
                raise
AmÃ©lioration 2 : Queue de publication avec prioritÃ©

# Au lieu de publier directement, ajouter Ã  une queue
@app.post("/bulk/drafts/{draft_id}/publish")
async def publish_bulk_draft(draft_id: str):
    job_id = add_to_queue(draft_id, priority="high")
    return {
        "ok": True,
        "status": "queued",
        "job_id": job_id,
        "message": "AjoutÃ© Ã  la file de publication"
    }
AmÃ©lioration 3 : Webhook de progression

# Quand la publication avance, envoyer des updates au front
async def publish_task(draft_id: str):
    await send_progress(draft_id, "Chargement des photos...", 25)
    await send_progress(draft_id, "Connexion Ã  Vinted...", 50)
    await send_progress(draft_id, "Remplissage du formulaire...", 75)
    await send_progress(draft_id, "Publication...", 90)
    await send_progress(draft_id, "TerminÃ© !", 100)
</lov-plan>
ğŸ¯ RÃ‰SUMÃ‰ ULTRA-SIMPLIFIÃ‰
Ce que tu dois faire MAINTENANT :

Ajoute les logs dÃ©taillÃ©s dans ton endpoint /bulk/drafts/{draft_id}/publish (copie-colle le code de l'Ã‰tape 1.1)
Essaie de publier un draft depuis le front
Regarde les logs backend â†’ ils vont te dire EXACTEMENT ce qui manque
Corrige le problÃ¨me identifiÃ© (photo manquante / session expirÃ©e / catÃ©gorie manquante)
Reteste jusqu'Ã  ce que Ã§a passe
Le "Not Found" vient forcÃ©ment d'un de ces 4 trucs :

âŒ Photo introuvable sur le disque
âŒ Session Vinted expirÃ©e
âŒ Champ obligatoire manquant
âŒ CatÃ©gorie non mappÃ©e
Les logs vont te le dire !

Parfait, j'ai maintenant une vision complÃ¨te de votre problÃ¨me. Laissez-moi vous expliquer ce qui bloque et vous donner un plan dÃ©taillÃ©.

ğŸ” DIAGNOSTIC DE L'ERREUR "NOT FOUND"
D'aprÃ¨s les requÃªtes rÃ©seau que j'ai analysÃ©es, votre backend retourne systÃ©matiquement :


{
  "ok": false,
  "status": "prepare_failed", 
  "reason": "Not Found"
}
Cette erreur se produit pendant la phase "prepare" de la publication, AVANT mÃªme d'essayer de publier sur Vinted. Le backend ne trouve pas quelque chose d'essentiel pour prÃ©parer la publication.

ğŸ¯ LES 4 CAUSES PROBABLES
Les photos ne sont pas trouvÃ©es sur le disque du serveur

Vos drafts contiennent des chemins comme /temp_photos/xxx.jpg
Le backend cherche probablement dans backend/data/temp_photos/xxx.jpg
Ou les photos ont Ã©tÃ© supprimÃ©es aprÃ¨s un certain temps
La session Vinted est expirÃ©e/absente

Le backend ne peut pas prÃ©parer la publication sans une session active
Votre cookie Vinted n'a peut-Ãªtre pas Ã©tÃ© sauvegardÃ© ou a expirÃ©
Le brouillon lui-mÃªme est incomplet

Certains champs obligatoires pour Vinted sont vides
Par exemple : condition, category, certaines infos manquantes
ProblÃ¨me de catÃ©gorie Vinted

Le backend essaie de mapper votre category vers un vinted_category_id
Cette catÃ©gorie n'existe pas dans la base Vinted
ğŸ“‹ PLAN D'ACTION COMPLET POUR PUBLIER SUR VINTED
PHASE 1 : DIAGNOSTIC BACKEND (30 min)
Ã‰tape 1.1 : Ajouter des logs dÃ©taillÃ©s dans /bulk/drafts/{draft_id}/publish
Dans ton endpoint de publication backend, ajoute ces logs AVANT toute tentative de publication :


@app.post("/bulk/drafts/{draft_id}/publish")
async def publish_bulk_draft(draft_id: str, options: dict = None):
    print(f"\n=== DÃ‰BUT PUBLICATION DRAFT {draft_id} ===")
    
    # 1. Charger le draft
    draft = load_draft(draft_id)  # ta fonction pour charger le draft
    if not draft:
        print(f"âŒ ERREUR: Draft {draft_id} introuvable en DB")
        return {"ok": False, "status": "prepare_failed", "reason": "Draft not found"}
    
    print(f"âœ… Draft chargÃ©: {draft['title']}")
    print(f"   - Photos: {draft.get('photos', [])}")
    print(f"   - Category: {draft.get('category')}")
    print(f"   - Condition: {draft.get('condition')}")
    print(f"   - Brand: {draft.get('brand')}")
    print(f"   - Size: {draft.get('size')}")
    
    # 2. VÃ©rifier les photos sur disque
    for photo_path in draft.get('photos', []):
        # Essayer plusieurs chemins possibles
        possible_paths = [
            photo_path,
            f"backend/data/{photo_path}",
            f"backend/data/temp_photos/{os.path.basename(photo_path)}",
            f"/tmp/{os.path.basename(photo_path)}"
        ]
        
        found = False
        for p in possible_paths:
            if os.path.exists(p):
                print(f"âœ… Photo trouvÃ©e: {p}")
                found = True
                break
        
        if not found:
            print(f"âŒ ERREUR: Photo introuvable: {photo_path}")
            print(f"   Chemins testÃ©s: {possible_paths}")
            return {
                "ok": False, 
                "status": "prepare_failed", 
                "reason": f"Photo introuvable: {os.path.basename(photo_path)}"
            }
    
    # 3. VÃ©rifier la session Vinted
    vinted_session = get_active_vinted_session()  # ta fonction
    if not vinted_session:
        print("âŒ ERREUR: Aucune session Vinted active")
        return {
            "ok": False,
            "status": "prepare_failed", 
            "reason": "Session Vinted expirÃ©e ou absente. Va dans Settings pour coller ton cookie."
        }
    
    print(f"âœ… Session Vinted active: user_id={vinted_session.get('user_id')}")
    
    # 4. Mapper la catÃ©gorie
    vinted_category_id = map_category_to_vinted(draft.get('category'))
    if not vinted_category_id:
        print(f"âŒ ERREUR: CatÃ©gorie '{draft.get('category')}' non mappÃ©e")
        return {
            "ok": False,
            "status": "prepare_failed",
            "reason": f"CatÃ©gorie '{draft.get('category')}' non reconnue par Vinted"
        }
    
    print(f"âœ… CatÃ©gorie mappÃ©e: {draft.get('category')} -> {vinted_category_id}")
    
    # 5. PrÃ©parer le payload Vinted
    vinted_payload = {
        "title": draft['title'],
        "description": draft.get('description', ''),
        "price": draft['price'],
        "category_id": vinted_category_id,
        "brand_id": get_brand_id(draft.get('brand')),  # si tu as un mapping
        "size_id": get_size_id(draft.get('size')),
        "status_id": get_condition_id(draft.get('condition')),
        "color_ids": [get_color_id(draft.get('color'))],
        "photos": [resolve_photo_path(p) for p in draft['photos']]
    }
    
    print(f"âœ… Payload Vinted prÃ©parÃ©: {vinted_payload}")
    
    # 6. MAINTENANT on peut essayer de publier sur Vinted
    # ... ton code de publication Playwright/Selenium
Ã‰tape 1.2 : CrÃ©er une fonction resolve_photo_path

def resolve_photo_path(photo_path: str) -> str:
    """Trouve le chemin absolu d'une photo en testant plusieurs emplacements"""
    possible_paths = [
        photo_path,
        f"backend/data/{photo_path}",
        f"backend/data/temp_photos/{os.path.basename(photo_path)}",
        f"/tmp/{os.path.basename(photo_path)}"
    ]
    
    for p in possible_paths:
        if os.path.exists(p):
            return os.path.abspath(p)
    
    raise FileNotFoundError(f"Photo introuvable: {photo_path}")
Ã‰tape 1.3 : Tester avec curl

curl -X POST "https://ton-backend.replit.dev/bulk/drafts/112f47df-dacd-41ca-ab07-752ff3838af4/publish" \
  -H "Authorization: Bearer TON_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"dry_run": false}'
RÃ©sultat attendu : Les logs vont te dire EXACTEMENT ce qui manque (photo, session, catÃ©gorie, etc.)

PHASE 2 : CORRIGER LES PROBLÃˆMES IDENTIFIÃ‰S (1h)
ScÃ©nario A : Photos introuvables
Solution : Modifier le code d'analyse de photos pour sauvegarder les chemins absolus


# Dans ton endpoint /bulk/photos/analyze
for file in uploaded_files:
    # Sauvegarder dans backend/data/temp_photos/
    save_path = f"backend/data/temp_photos/{uuid.uuid4()}.jpg"
    with open(save_path, 'wb') as f:
        f.write(await file.read())
    
    # Stocker le chemin COMPLET dans le draft
    draft_photos.append(save_path)  # PAS juste le nom de fichier
ScÃ©nario B : Session Vinted expirÃ©e
Solution : Aller dans /settings et recoller ton cookie Vinted frais

Ouvre Vinted dans ton navigateur
F12 â†’ Onglet RÃ©seau â†’ RafraÃ®chir la page
Clique sur n'importe quelle requÃªte vers vinted.fr
Copie TOUT le header Cookie (pas juste une partie)
Copie aussi le User-Agent
Va sur /settings dans ton app
Colle les deux valeurs et clique "Sauvegarder"
VÃ©rifie que le backend confirme la session
ScÃ©nario C : Champs manquants (condition, etc.)
Solution : Modifier le SYSTEM_PROMPT OpenAI pour forcer ces champs


SYSTEM_PROMPT = """
Tu dois OBLIGATOIREMENT retourner ces champs:
- title (string, non vide)
- description (string, au moins 50 caractÃ¨res)
- price (number, > 0)
- condition (string, EXACTEMENT UN DE: "Neuf avec Ã©tiquette", "Neuf sans Ã©tiquette", "TrÃ¨s bon Ã©tat", "Bon Ã©tat", "Satisfaisant")
- category (string, exemples: "Pulls & Gilets", "Pantalons & Jeans", "Robes", etc.)
- size (string, exemples: "XS", "S", "M", "L", "XL", "XXL")
- brand (string, si identifiable)
- color (string, exemples: "Noir", "Blanc", "Bleu", etc.)

SI UN CHAMP N'EST PAS IDENTIFIABLE, mets une valeur par dÃ©faut cohÃ©rente:
- condition: "Bon Ã©tat" (par dÃ©faut)
- category: "VÃªtements" (si vraiment incertain)
- size: "M" (si invisible sur photo)
"""
ScÃ©nario D : CatÃ©gorie non mappÃ©e
Solution : CrÃ©er un mapping robuste


CATEGORY_MAPPING = {
    "Pulls & Gilets": 20,  # ID Vinted pour "Pulls"
    "Pantalons & Jeans": 91,
    "Robes": 16,
    "VÃªtements": 1,  # CatÃ©gorie gÃ©nÃ©rique par dÃ©faut
    # ... ajouter toutes les catÃ©gories
}

def map_category_to_vinted(category: str) -> int:
    # Essayer exact match
    if category in CATEGORY_MAPPING:
        return CATEGORY_MAPPING[category]
    
    # Essayer fuzzy match
    for key in CATEGORY_MAPPING:
        if category.lower() in key.lower() or key.lower() in category.lower():
            return CATEGORY_MAPPING[key]
    
    # Fallback: catÃ©gorie gÃ©nÃ©rique
    return 1  # "VÃªtements"
PHASE 3 : CORRIGER LE FRONTEND (30 min)
Fix 1 : Le champ condition vide dans les drafts
ProblÃ¨me : Le backend renvoie "condition": "Bon Ã©tat" (franÃ§ais) mais le Select attend "good" (anglais)

Solution dÃ©jÃ  appliquÃ©e dans BulkDraftEdit.tsx : mapping bidirectionnel


const CONDITION_MAP = {
  "new_with_tags": "Neuf avec Ã©tiquette",
  "new_without_tags": "Neuf sans Ã©tiquette", 
  "very_good": "TrÃ¨s bon Ã©tat",
  "good": "Bon Ã©tat",
  "satisfactory": "Satisfaisant"
};

// Quand on charge le draft:
const frenchCondition = draft.condition; // "Bon Ã©tat"
const englishValue = Object.keys(CONDITION_MAP).find(
  key => CONDITION_MAP[key] === frenchCondition
); // "good"
âœ… Cette partie est dÃ©jÃ  corrigÃ©e cÃ´tÃ© front

Fix 2 : Upload de photos dans un draft existant
Backend nÃ©cessaire : CrÃ©er l'endpoint POST /bulk/drafts/{draft_id}/photos


@app.post("/bulk/drafts/{draft_id}/photos")
async def add_photos_to_draft(draft_id: str, files: List[UploadFile]):
    draft = load_draft(draft_id)
    if not draft:
        raise HTTPException(404, "Draft not found")
    
    new_photos = []
    for file in files:
        save_path = f"backend/data/temp_photos/{uuid.uuid4()}.jpg"
        with open(save_path, 'wb') as f:
            f.write(await file.read())
        new_photos.append(save_path)
    
    # Ajouter aux photos existantes
    draft['photos'].extend(new_photos)
    save_draft(draft_id, draft)
    
    return {"ok": True, "photos": draft['photos']}
Fix 3 : Titres et tailles trop complexes
Backend : Modifier le SYSTEM_PROMPT OpenAI


SYSTEM_PROMPT = """
RÃˆGLES STRICTES pour title:
- Maximum 60 caractÃ¨res
- Format: [Marque] [Type] [Couleur] [Taille]
- Exemple: "Burberry Jogging noir XS"
- PAS de mesures (cm, Y)
- PAS d'Ã©quivalences (â‰ˆ)
- PAS d'Ã©tat dans le titre

RÃˆGLES STRICTES pour size:
- UNIQUEMENT: XS, S, M, L, XL, XXL
- SI taille enfant dÃ©tectÃ©e (ex: 16Y): convertir en taille adulte Ã©quivalente
  - 14-16Y -> XS
  - 16-18Y -> S
- Si incertain: "M" par dÃ©faut
- CRÃ‰ER UN NOUVEAU CHAMP size_details pour les dÃ©tails (ex: "16Y / 165 cm")
"""
PHASE 4 : TESTS & VALIDATION (30 min)
Test 1 : CrÃ©er un nouveau draft propre
Va sur /bulk-upload
Upload 1-2 photos d'un article simple (t-shirt uni par exemple)
Attends la gÃ©nÃ©ration du draft
Va dans le draft
VÃ©rifie que TOUS les champs sont remplis (surtout condition)
Clique "Sauvegarder"
Test 2 : Publier en dry-run
Dans le mÃªme draft, clique "Publier"
VÃ©rifie dans les logs backend que toutes les Ã©tapes passent :
âœ… Draft chargÃ©
âœ… Photo trouvÃ©e
âœ… Session Vinted active
âœ… CatÃ©gorie mappÃ©e
âœ… Payload prÃ©parÃ©
Si dry-run rÃ©ussit â†’ passe au test rÃ©el
Test 3 : Publication rÃ©elle
Assure-toi que ta session Vinted est fraÃ®che (< 24h)
Clique "Publier" en mode rÃ©el
Surveille les logs backend pour voir oÃ¹ Ã§a bloque
Si captcha Vinted â†’ normal, complÃ¨te-le manuellement
Test 4 : VÃ©rifier sur Vinted
Va sur ton profil Vinted
VÃ©rifie que l'article est bien publiÃ©
VÃ©rifie que les photos, titre, prix correspondent
PHASE 5 : OPTIMISATIONS (bonus)
AmÃ©lioration 1 : Retry automatique si session expirÃ©e

def publish_with_retry(draft_id: str, max_retries=2):
    for attempt in range(max_retries):
        try:
            return publish_to_vinted(draft_id)
        except VintedSessionExpired:
            if attempt < max_retries - 1:
                print("Session expirÃ©e, attente de nouveau cookie...")
                time.sleep(60)  # Attendre que l'utilisateur recolle son cookie
            else:
                raise
AmÃ©lioration 2 : Queue de publication avec prioritÃ©

# Au lieu de publier directement, ajouter Ã  une queue
@app.post("/bulk/drafts/{draft_id}/publish")
async def publish_bulk_draft(draft_id: str):
    job_id = add_to_queue(draft_id, priority="high")
    return {
        "ok": True,
        "status": "queued",
        "job_id": job_id,
        "message": "AjoutÃ© Ã  la file de publication"
    }
AmÃ©lioration 3 : Webhook de progression

# Quand la publication avance, envoyer des updates au front
async def publish_task(draft_id: str):
    await send_progress(draft_id, "Chargement des photos...", 25)
    await send_progress(draft_id, "Connexion Ã  Vinted...", 50)
    await send_progress(draft_id, "Remplissage du formulaire...", 75)
    await send_progress(draft_id, "Publication...", 90)
    await send_progress(draft_id, "TerminÃ© !", 100)
</lov-plan>
ğŸ¯ RÃ‰SUMÃ‰ ULTRA-SIMPLIFIÃ‰
Ce que tu dois faire MAINTENANT :

Ajoute les logs dÃ©taillÃ©s dans ton endpoint /bulk/drafts/{draft_id}/publish (copie-colle le code de l'Ã‰tape 1.1)
Essaie de publier un draft depuis le front
Regarde les logs backend â†’ ils vont te dire EXACTEMENT ce qui manque
Corrige le problÃ¨me identifiÃ© (photo manquante / session expirÃ©e / catÃ©gorie manquante)
Reteste jusqu'Ã  ce que Ã§a passe
Le "Not Found" vient forcÃ©ment d'un de ces 4 trucs :

âŒ Photo introuvable sur le disque
âŒ Session Vinted expirÃ©e
âŒ Champ obligatoire manquant
âŒ CatÃ©gorie non mappÃ©e
Les logs vont te le dire !





